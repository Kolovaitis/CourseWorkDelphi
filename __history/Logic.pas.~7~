unit Logic;

interface

type
   PCardPointer = ^TCard;

   TCard = record
      EqualCard: PCardPointer;
      IsTurned: Boolean;
      Row: Integer;
      Column: Integer;
      PairNumber: Integer;
   end;

   TMatrix = array of array of TCard;

   TLogic = class
   private
      IsNowTurned: Boolean;
      PastTurnedCard: PCardPointer;
      procedure RandomizeCards;
   public
      Field: TMatrix;
      FlipCard: procedure(Row, Column: Integer) of object;
      FlipTwo: procedure(Row1, Column1, Row2, Column2: Integer) of object;
      OnTouch: procedure(Row, Column: Integer) of object;
      procedure OnCardTouched(Row, Column: Integer);
      constructor Create(RowCount, ColumnCount: Integer);

   end;

implementation

{ TLogic }

constructor TLogic.Create(RowCount, ColumnCount: Integer);
var
   i: Integer;
   j: Integer;
begin
   SetLength(Field, RowCount, ColumnCount);
   for i := 0 to RowCount - 1 do
      for j := 0 to ColumnCount - 1 do
      begin
         with Field[i, j] do
         begin
            IsTurned := false;
            Row := i;
            Column := j;
         end;
      end;
   RandomizeCards;
   IsNowTurned := false;
   OnTouch := Self.OnCardTouched;
end;

procedure TLogic.OnCardTouched(Row, Column: Integer);
begin
   if (not Field[Row, Column].IsTurned) then
   begin
      if (IsNowTurned) then
      begin
         FlipCard(Row, Column);
         Field[Row, Column].IsTurned := true;
         IsNowTurned := false;
         if (Field[Row, Column].EqualCard <> PastTurnedCard) then
         begin
            FlipTwo(Row, Column, PastTurnedCard.Row, PastTurnedCard.Column);
            PastTurnedCard.IsTurned := false;
            Field[Row, Column].IsTurned := false;
         end
      end
      else
      begin
         IsNowTurned := true;
         Field[Row, Column].IsTurned := true;
         PastTurnedCard := @Field[Row, Column];
         FlipCard(Row, Column);
      end;
   end;

end;

procedure TLogic.RandomizeCards;
var
   i: Integer;
   j: Integer;
   Counter: Integer;
   MaxI: Integer;
   MaxJ: Integer;
  CountOfCells: Integer;
  ThisI: Integer;
  ThisJ: Integer;
  NewI: Integer;
  NewJ: Integer;
  PairI: Integer;
  PairJ: Integer;
begin
   Counter := 0;
   MaxI := High(Field);
   MaxJ := High(Field[0]);
   for i := 0 to MaxI do
   begin
      j := 0;
      while j < MaxJ do
      begin
         Field[i, j].EqualCard := @Field[i, j + 1];
         Field[i, j + 1].EqualCard := @Field[i, j];
         Field[i, j].PairNumber := Counter;
         Field[i, j + 1].PairNumber := Counter;
         Inc(j, 2);
         Inc(Counter);
      end;
   end;
   CountOfCells:= (MaxI+1)*(MaxJ+1);
   for i := 0 to CountOfCells-1 do
   begin

      ThisI:=i div (MaxJ+1);
      ThisJ:=i mod (MaxJ+1);
      PairI:=Field[ThisI,ThisJ].EqualCard.Row;
      PairJ:=Field[ThisI,ThisJ].EqualCard.Column;
      NewI:=Random(MaxI);
      NewJ:=Random(MaxJ);
      while ((NewI=PairI)and(NewJ = PairJ)) do
      begin
         NewI:=Random(MaxI);
         NewJ:=Random(MaxJ);
      end;

      Field[PairI,PairJ].EqualCard:= Field[NewI,NewJ].EqualCard;
      Field[PairI,PairJ].PairNumber:= Field[NewI,NewJ].PairNumber;
      Field[NewI,NewJ].EqualCard.EqualCard:=@Field[PairI,PairJ];

      Field[ThisI,ThisJ].EqualCard:= @Field[NewI,NewJ];
      Field[NewI,NewJ].PairNumber:= Field[ThisI,ThisJ].PairNumber;
      Field[NewI,NewJ].EqualCard:=@Field[ThisI,ThisJ];


   end;
end;

end.
