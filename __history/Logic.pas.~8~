unit Logic;

interface

type
   PCardPointer = ^TCard;

   TCard = record
      EqualCard: PCardPointer;
      IsTurned: Boolean;
      Row: Integer;
      Column: Integer;
      PairNumber: Integer;
   end;

   TMatrix = array of array of TCard;

   TLogic = class
   private
      IsNowTurned: Boolean;
      PastTurnedCard: PCardPointer;
      procedure RandomizeCards;
   public
      Field: TMatrix;
      FlipCard: procedure(Row, Column: Integer) of object;
      FlipTwo: procedure(Row1, Column1, Row2, Column2: Integer) of object;
      OnTouch: procedure(Row, Column: Integer) of object;
      WinScenary: procedure() of object;
      procedure OnCardTouched(Row, Column: Integer);
      constructor Create(RowCount, ColumnCount: Integer);

   end;

implementation

{ TLogic }

constructor TLogic.Create(RowCount, ColumnCount: Integer);
var
   i: Integer;
   j: Integer;
begin
   SetLength(Field, RowCount, ColumnCount);
   for i := 0 to RowCount - 1 do
      for j := 0 to ColumnCount - 1 do
      begin
         with Field[i, j] do
         begin
            IsTurned := false;
            Row := i;
            Column := j;
         end;
      end;
   RandomizeCards;
   IsNowTurned := false;
   OnTouch := Self.OnCardTouched;
end;

procedure TLogic.OnCardTouched(Row, Column: Integer);
begin
   if (not Field[Row, Column].IsTurned) then
   begin
      if (IsNowTurned) then
      begin
         FlipCard(Row, Column);
         Field[Row, Column].IsTurned := true;
         IsNowTurned := false;
         if (Field[Row, Column].EqualCard <> PastTurnedCard) then
         begin
            FlipTwo(Row, Column, PastTurnedCard.Row, PastTurnedCard.Column);
            PastTurnedCard.IsTurned := false;
            Field[Row, Column].IsTurned := false;
         end
      end
      else
      begin
         IsNowTurned := true;
         Field[Row, Column].IsTurned := true;
         PastTurnedCard := @Field[Row, Column];
         FlipCard(Row, Column);
      end;
   end;

end;

procedure TLogic.RandomizeCards;
var
   i: Integer;
   j: Integer;
   Counter: Integer;
   MaxI: Integer;
   MaxJ: Integer;
  Index2y: Integer;
  Index2x: Integer;
  Index1y: Integer;
  Index1x: Integer;
  TempEq: PCardPointer;
  TempPairNumber: Integer;

begin
   Counter := 0;
   MaxI := High(Field);
   MaxJ := High(Field[0]);
   for i := 0 to MaxI do
   begin
      j := 0;
      while j < MaxJ do
      begin
         Field[i, j].EqualCard := @Field[i, j + 1];
         Field[i, j + 1].EqualCard := @Field[i, j];
         Field[i, j].PairNumber := Counter;
         Field[i, j + 1].PairNumber := Counter;
         Inc(j, 2);
         Inc(Counter);
      end;
   end;

   for i := 1 to 2*MaxI*MaxJ do
   begin
      Index1x:= Random(MaxI+1);
      Index1y:= Random(MaxJ+1);
      Index2x:= Random(MaxI+1);
      Index2y:= Random(MaxJ+1);
      If(Field[Index2x, Index2y].EqualCard<>@Field[Index1x,Index1y])then
      begin
      TempPairNumber:=Field[Index1x,Index1y].PairNumber;
      Field[Index1x,Index1y].PairNumber:=Field[Index2x,Index2y].PairNumber;
      Field[Index2x, Index2y].PairNumber:=TempPairNumber;
      TempEq:=Field[Index1x,Index1y].EqualCard;
      Field[Index1x,Index1y].EqualCard:=Field[Index2x,Index2y].EqualCard;
      Field[Index2x, Index2y].EqualCard:=TempEq;
      Field[Index1x,Index1y].EqualCard.EqualCard:= @Field[Index1x,Index1y];
      Field[Index2x,Index2y].EqualCard.EqualCard:= @Field[Index2x,Index2y];
      end;
   end;

end;

end.
